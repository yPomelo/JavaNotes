1、构造函数：对象一旦建立就会调用与之对应的构造函数
2、构造代码块：
    作用：给对象进行初始化
    对象一建立就运行，且优先于构造函数执行
    和构造函数的区别：构造代码块是给所有对象进行统一初始化
    而构造函数是给对应对象初始化

3、this关键字：this代表它所在函数所属对象的引用
简单说：哪个对象在调用this所在的函数，this就代表哪个对象（每个教师又一张椅子属于老师，谁过来上课，椅子属于谁）

4、this的应用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。
（看到this想到：这是一个对象的引用，this和p1的地址值相同，指向了同一个对象）

5、this语句 this()：构造函数之间相互调用只能用给this语句 this语句只能定义在构造函数的第一行，因为初始化要先执行
this语句不能用在一般函数中

6、静态static：用于修饰成员（成员变量、成员函数），静态修饰内容被对象所共享，当成员被静态修饰后，就对了一个调用方式，除了可以被对象调用之外，还可以被类名直接调用。
类名.静态成员

7、static的特点
    1.随着类的加载而加载，也就是说静态会随着类的消失而消失。说明它的生命周期最长
    2.优先于对象存在，静态先存在，对象后存在
    3.被所有对象共享
    4.可以被类名直接调用

8、实例变量（成员变量）和类变量（静态成员变量）的区别：
    1.存放位置：类变量随着类的加载存放在方法区当中
               实例变量随着对象的建立而存在于堆内存当中
    2.生命周期：类变量生命周期最长，随着类的消失而消失
               实例变量生命周期随着对象的消失而消失

9、静态使用注意事项：
    1.静态方法只能访问静态成员（静态方法静态变量）。非静态方案既可以访问静态也可以访问非静态。
    2.静态方法中不可以定义this，super关键字。因为静态优先于对象存在，所以静态方法中不可以出现this、super
    3.主函数是静态的
        主函数：是一个特殊的函数，作为程序的入口，可以被jvm调用。

        主函数的定义：
        public：代表该函数的访问权限是最大的
        static：代表主函数随着类的加载就已经存在了
        void：主函数没有具体的返回值
        main：不是关键字，但是是一个特殊的单词，可以被jvm识别
        函数的参数：（String[] args），是一个数组，字符串类型的数组
        主函数是固定格式的：jvm识别
        jvm在调用主函数时，传入的是new String[0]
        java +类名 +参数
10、静态有利有弊
    1.利：对对象的共享数据进行单独空间的存储，节省空间。没有必要每个对象中都存储一份。
          可以直接被类名调用。
    2.弊：生命周期过长
          访问出现局限性（静态虽好，只能访问静态）

11、什么时候使用静态static？
    要从两方面下手（因为静态修饰的内容有成员变量和函数）：
    1.什么时候定义静态变量：当对象中出现共享数据时，该数据被静态所修饰，存在于共享区，特有数据要定义成非静态，存在于堆内存中。
    2.什么时候定义静态函数：当功能内部没有访问到非静态数据（对象的特有数据），那么该功能可以定义成静态。

12、默认构造函数的权限是随着类的变化而变化的

13、静态代码块：随着类的加载而执行，只执行一次

14、Person p = new Person("zhangsan",20)
    该句话都做了什么事情？
    1.因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。
    2.执行该类中的static静态代码块，如果有的话，给Person.class类进行初始化。
    3.在堆内存中开辟空间，分配内存地址。
    4.在堆内存中建立对象特有的属性，并进行默认初始化。
    5.对对象进行构造代码块的初始化。
    7.对对象进行构造函数初始化。
    8.将内存地址赋给栈内存中的P变量。
    （默认初始化->显式初始化->构造代码块初始化->构造函数初始化）

15、单例设计模式：解决一个类在内存中只存在一个对象
        1.为了避免其他程序过多建立该类对象，先禁止其他程序建立该对象（将构造函数私有化）
        2.还为了让其他程序可以访问到该类对象，只好在本类中自定义一个对象（在类中创建一个本类对象）
        3.对了方便其他程序对自定义对象的访问，可以对外提供一些访问方式（对外提供公有方法访问该对象）
    饿汉式：先初始化对象，类一进内存，就已经创建好了对象
    懒汉式：方法被调用时，才初始化对象

16、重载：只看同名函数的参数列表；
    重写：子父类方法要一模一样

17、在对子类对象进行初始化时，父类的构造函数也会运行，因为子类的构造函数默认第一行有一条隐式的super()

18、final：
    1.可以修饰类、函数、变量
    2.被final修饰的类不可以被继承
    3.被final修饰的方法不可以被复写
    4.被final修饰的变量是一个常量只能赋值一次

19、抽象：就是看不懂
    抽象类的特点：
    1.抽象方法一定在抽象类中
    2.抽象方法和抽象类必须被abstract关键字修饰
    3.抽象类不可以用new创建对象，因为调用抽象方法没意义
    4.抽象类中的方法要被使用，必须由子类腹泻其所有的抽象方法后，建立子类对象，来调用。
        如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。
20、接口：初期理解，可以认为是一个特殊的抽象类，当抽象类中的方法都是抽象的，那么类可以通过接口来表示
    interface用于定义接口
    接口定义时格式特点：常量：public static final
                        方法：public abstract
    记住：接口中的成员都是public的
21、多态：
    1.多态的体现：父类的引用指向了子类对象
    2.多态的前提：必须类与类之间有关系，要么继承，要么实现
                 通常还有一个前提，存在子类覆盖
    3.多态的好处：大大提高了程序的扩展性
    4.多态的弊端：只能使用父类的引用访问父类中的成员
22、异常
    try
    {
        需要被检测的代码
    }
    catch(异常类 变量)
    {
        处理异常的代码
    }
    finally
    {
        一定会执行的语句
    }
    其实jvm默认的异常处理机制，就是在调用printStackTrace()方法，打印异常的堆栈跟踪信息
23、throw和throws的区别
    throws后面跟着异常类，可以跟多个，用逗号隔开
    throw后面跟的是异常对象
    throws使用在函数上
    Throw使用在函数内
    class Demo
    {
        int div(int a,int b)throws FuShuException
        {
            if(b<0)
            throw new FuShuException("出现了除数是负数的情况")
            return a/b;
        }
    }
24、Exception中有一个特殊的子类异常RuntimeException运行时异常
    如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过
    如果在函数上声明了该异常，调用者可以不用进行处理，编译一样通过
    之所以不用再函数伤命，是因为不需要让调用者处理
    当该异常发生时，希望程序停止运行，因为在运行时出现了无法继续运算的情况，希望停止程序后，对代码进行修正
    